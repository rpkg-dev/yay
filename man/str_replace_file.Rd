% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/yay-GEN.R
\name{str_replace_file}
\alias{str_replace_file}
\title{Replace matched patterns in text files}
\usage{
str_replace_file(
  path,
  pattern,
  process_line_by_line = FALSE,
  eol = c("LF", "CRLF", "CR", "LFCR"),
  verbose = TRUE,
  n_context_chrs = 20L,
  show_rel_path = TRUE,
  run_dry = FALSE
)
}
\arguments{
\item{path}{Paths to the text files. A character vector.}

\item{pattern}{A named character vector with patterns as names and replacements as values (\code{c(pattern1 = replacement1)}). Patterns are interpreted as
regular expressions as described in \code{\link[stringi:about_search_regex]{stringi::stringi-search-regex()}}. Replacements are interpreted as-is, except that references of the form \verb{\\1}, \verb{\\2},
etc. will be replaced with the contents of the respective matched group (created in patterns using \verb{()}). Pattern-replacement pairs are processed in the
order given, meaning that first listed pairs are applied before later listed ones.}

\item{process_line_by_line}{Whether each line in a file should be treated as a separate string or the whole file as one single string. While the latter is
more performant, you probably want the former if you're using \code{"^"} or \code{"$"} in your \code{pattern}s.}

\item{eol}{End of line (EOL) control character sequence. Only relevant if \code{process_line_by_line = TRUE}. One of
\itemize{
\item \code{"LF"} for the line feed (LF) character (\code{"\\n"}). The standard on Unix and Unix-like systems (Linux, macOS, *BSD, etc.) and the \strong{default}.
\item \code{"CRLF"} for the carriage return + line feed (CR+LF) character sequence (\code{"\\r\\n"}). The standard on Microsoft Windows, DOS and some other systems.
\item \code{"CR"} for the carriage return (CR) character (\code{"\\r"}). The standard on classic Mac OS and some other antiquated systems.
\item \code{"LFCR"} for the line feed + carriage return (LF+CR) character sequence (\code{"\\n\\r"}). The standard on RISC OS and some other exotic systems.
}}

\item{verbose}{Whether to display replacements on the console.}

\item{n_context_chrs}{The (maximum) number of characters displayed around the actual \code{string} and its replacement. The number refers to a single side of
\code{string}/replacement, so the total number of context characters is at the maximum \code{2 * n_context_chrs}. Only relevant if \code{verbose = TRUE}.}

\item{show_rel_path}{Whether to display file \code{path}s as relative from the current working directory. If \code{FALSE}, absolute paths are displayed. Only relevant
if \code{verbose = TRUE}.}

\item{run_dry}{Show replacements on the console only, without actually modifying any files. Implies \code{verbose = TRUE}.}
}
\value{
\code{path} invisibly.
}
\description{
Applies pattern-based string replacements to one or more files. Expects a series of regular-expression-replacement pairs that are applied one-by-one in the
given order. All performed replacements are displayed on the console by default (\code{verbose = TRUE}), optionally without actually changing any file content
(\code{run_dry = TRUE}).
}
\details{
Note that \code{process_line_by_line} requires the \href{https://en.wikipedia.org/wiki/Newline}{line ending standard (EOL)} of the input files to be correctly set in
\code{eol}. It \emph{always} defaults to \code{"LF"} (Unix standard) since this is something which cannot be reliably detected without complex heuristics (and even then
not unambiguously in all edge cases). Simply deriving a default depending on the host OS (i.a. \code{"LF"} on Unix systems like Linux and macOS and \code{"CRLF"} on
Windows) seems like a really bad idea with regard to cross-system collaboration (files shared via Git etc.), thus it was refrained from.

The text files are assumed to be in \href{https://en.wikipedia.org/wiki/UTF-8}{UTF-8 character encoding}, other encodings are not supported.
}
\seealso{
Other string functions:
\code{\link{str_normalize_file}()},
\code{\link{str_normalize}()},
\code{\link{str_replace_verbose}()}
}
\concept{string}
