# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/yay.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literate programming approach used applying the R Markdown format.

# yay: Delightful Convenience Functions
# Copyright (C) 2021 Salim Br√ºggemann
# 
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

utils::globalVariables(names = c(".",
                                 "end",
                                 "i_pattern",
                                 "minus",
                                 "pattern",
                                 "plus",
                                 "replacement",
                                 "start",
                                 "status"))

unicode_ellipsis <- "\u2026"

# dark background colors that are easy on the eyes
bg_red_dark <- cli::make_ansi_style("#330000",
                                    bg = TRUE,
                                    colors = 2L^24L)

bg_green_dark <- cli::make_ansi_style("#003300",
                                      bg = TRUE,
                                      colors = 2L^24L)

pkg <- utils::packageName()

as_line_feed_chr <- function(eol = c("LF", "CRLF", "CR", "LFCR")) {
  
  switch(EXPR = rlang::arg_match(eol),
         LF = "\n",
         CRLF = "\r\n",
         CR = "\r",
         LFCR = "\n\r")
}







#' Regular expression patterns and replacements for text normalization
#'
#' @format `r pkgsnip::return_label("data")`
#' @seealso [`regex_file_normalization`] [str_normalize()]
#'
#' @examples
#' # unnest the pattern column
#' tidyr::unnest_longer(data = yay::regex_text_normalization,
#'                      col = pattern)
"regex_text_normalization"

#' Regular expression patterns and replacements for file normalization
#'
#' @format `r pkgsnip::return_label("data")`
#' @seealso [`regex_text_normalization`] [str_normalize()]
#'
#' @examples
#' # unnest the pattern column
#' tidyr::unnest_longer(data = yay::regex_file_normalization,
#'                      col = pattern)
"regex_file_normalization"

#' Determine the differences between two data frames/tibbles in tabular diff format
#'
#' Compares two [data frames][base::data.frame()]/[tibbles][tibble::tbl_df] (or two objects coercible to tibbles like
#' [matrices][base::matrix()]) and offers to inspect any differences in [tabular diff format](https://paulfitz.github.io/daff-doc/spec.html) as neatly rendered
#' HTML.
#'
#' This function is basically a convenience wrapper combining [pal::is_equal_df()], [daff::diff_data()] and [daff::render_diff()]. If run non-interactively or
#' `ask = FALSE`, the differences will be shown right away, otherwise the user will be asked on the console.
#'
#' Note that in tabular diff format, only changes in the _column content_ of `x` and `y` are visible, meaning that the following properties and changes
#' therein won't be displayed:
#'
#' - column types (e.g. integer vs. double)
#' - row names and other attributes
#'
#' @param x The data frame / tibble to check for changes.
#' @param y The data frame / tibble that `x` should be checked against, i.e. the reference.
#' @param ignore_order Whether or not to ignore the order of columns and rows.
#' @param ids A character vector of column names that make up a [primary key](https://en.wikipedia.org/wiki/Primary_key), if known. If `NULL`, heuristics are
#'   used to find a decent key (or a set of decent keys).
#' @param ask Whether to ask interactively if the resulting difference object should be opened in case `x` and `y` differ. If `FALSE`, it will be opened right
#'   away. Only relevant if run [interactively][base::interactive()].
#' @param bypass_rstudio_viewer If `TRUE`, `x` and `y` actually differ, and `ask` is set to `TRUE`, the resulting difference object will be
#'   opened in the system's default web browser instead of RStudio's built-in viewer. Only relevant if run within RStudio.
#' @param verbose Whether or not to also output the differences detected by [pal::is_equal_df()] to the console.
#' @param max_diffs The maximum number of differences shown on the console. Only relevant if `verbose = TRUE`.
#' @param caption The caption of the rendered difference object. It is passed to [glue::glue()] allowing its string interpolation syntax to be used. A character
#'   scalar.
#' @param diff_text The text to display on the console in case `x` and `y` differ. It is passed to [glue::glue()] allowing its string interpolation syntax to be
#'   used. A character scalar.
#' @param ask_text The text that is displayed when `ask = TRUE`. Ignored if `ask = FALSE`. A character scalar.
#' @param ... Further arguments passed on to [daff::diff_data()], excluding `data`, `data_ref`, `ids`, `ordered`, and `columns_to_ignore`.
#' @inheritParams pal::is_equal_df
#'
#' @return A [difference object][daff::daff], invisibly. It could be rendered later using [daff::render_diff()], for example.
#' @family tibble
#' @export
#'
#' @examples
#' \dontrun{
#' mtcars %>%
#'   dplyr::mutate(dplyr::across(c(cyl, gear),
#'                               ~ dplyr::if_else(. > 4, . * 2, .))) %>%
#'   yay::show_diff(mtcars)}
show_diff <- function(x,
                      y,
                      ignore_order = FALSE,
                      ignore_col_types = FALSE,
                      ids = NULL,
                      ask = TRUE,
                      bypass_rstudio_viewer = FALSE,
                      verbose = TRUE,
                      max_diffs = 10L,
                      diff_text = "{x_lbl} is different from {y_lbl}",
                      ask_text = "Do you wish to display the changes in tabular diff format?",
                      caption = "{x_lbl} vs. {y_lbl}",
                      ...) {
  
  checkmate::assert_character(ids,
                              any.missing = FALSE,
                              null.ok = TRUE)
  checkmate::assert_string(diff_text)
  checkmate::assert_string(ask_text)
  checkmate::assert_string(caption)
  checkmate::assert_flag(ignore_order)
  checkmate::assert_flag(ask)
  checkmate::assert_flag(bypass_rstudio_viewer)
  pal::assert_pkg("daff")
  
  pal::check_dots_named(...,
                        .function = daff::diff_data,
                        .forbidden = c("data",
                                       "data_ref",
                                       "ids",
                                       "ordered",
                                       "columns_to_ignore"))
  
  # generate `x`/`y` labels
  x_lbl <- deparse(substitute(x))
  y_lbl <- deparse(substitute(y))
  
  if (length(x_lbl) > 1L || x_lbl == "." || make.names(x_lbl) != x_lbl) {
    x_lbl <- "`x`"
  } else x_lbl <- glue::glue("`x` (`{x_lbl}`)")
  
  if (length(y_lbl) > 1L || y_lbl == "." || make.names(y_lbl) != y_lbl) {
    y_lbl <- "`y`"
  } else y_lbl <- glue::glue("`y` (`{y_lbl}`)")
  
  # generate HTML caption
  caption %<>% glue::glue()
  n_backtick <- caption %>% stringr::str_count(pattern = "`")
  
  if (n_backtick) {
    
    caption %<>%
      purrr::reduce(.x = 1:n_backtick,
                    .init = .,
                    .f = function(string, i) {
                      
                      stringr::str_replace(string = string,
                                           pattern = "`",
                                           replacement = dplyr::if_else(i %% 2L == 0L,
                                                                        "</code>",
                                                                        "<code>"))
                    })
  }
  
  daff_obj <- daff::diff_data(data = x,
                              data_ref = y,
                              ids = ids,
                              ordered = !ignore_order)
  
  diff <- pal::is_equal_df(x = x,
                           y = y,
                           ignore_col_order = ignore_order,
                           ignore_row_order = ignore_order,
                           ignore_col_types = ignore_col_types,
                           quiet = TRUE,
                           return_waldo_compare = TRUE)
  
  if (length(diff)) {
    
    pal::assert_pkg("cli")
    
    if (verbose) {
      cli::cli_alert_info(text = paste0(diff_text, ":"))
      cat("\n")
      print(diff)
      
    } else {
      cli::cli_alert_info(text = paste0(diff_text, "."))
    }
    
    open_diff <- TRUE
    
    if (ask && interactive()) {
      pal::assert_pkg("yesno")
      cat("\n")
      open_diff <- yesno::yesno2(ask_text)
    }
    
    if (open_diff) {
      
      if (interactive()) {
        
        if (bypass_rstudio_viewer) {
          pal::assert_pkg("withr")
          withr::with_options(new = list(viewer = NULL),
                              code = daff::render_diff(diff = daff_obj,
                                                       view = TRUE,
                                                       title = caption))
        } else {
          daff::render_diff(diff = daff_obj,
                            view = TRUE,
                            title = caption)
        }
      } else {
        
        pal::assert_pkg("xopen")
        tmp_file <- fs::file_temp(pattern = "yay-show_diff_",
                                  ext = "html")
        
        daff::render_diff(diff = daff_obj,
                          file = tmp_file,
                          view = FALSE,
                          title = caption)
        
        xopen::xopen(target = glue::glue("file://{tmp_file}"),
                     quiet = TRUE)
        cli::cli_alert_info("A new tab displaying the changes has been opened in your default web browser.")
      }
    }
  }
  
  invisible(daff_obj)
}

#' Open as temporary spreadsheet
#'
#' Writes an \R object -- usually tabular data like a dataframe or [tibble][tibble::tibble()] -- to a temporary spreadsheet and subsequently opens that
#' spreadsheet in the system's default application using [xopen::xopen()]. The latter is usually equivalent to double-clicking on the file in a file browser.
#'
#' @param x A dataframe or [tibble][tibble::tibble()], or something coercible to.
#' @param format The spreadsheet format to use. One of
#'   - `"csv"` for a [comma-separated values](https://en.wikipedia.org/wiki/Comma-separated_values) file written using [readr::write_csv()]. The default.
#'   - `"xlsx"` for an [Office Open XML](https://en.wikipedia.org/wiki/Office_Open_XML) file commonly used by Microsoft Excel 2007+, written using
#'     [writexl::write_xlsx()].
#' @param quiet Whether or not to echo the command to open the temporary spreadsheet on the console before running it.
#'
#' @return `x` invisibly.
#' @family tibble
#' @export
#'
#' @examples
#' \dontrun{
#' yay::open_as_tmp_spreadsheet(mtcars,
#'                              format = "xslx")}
open_as_tmp_spreadsheet <- function(x,
                                    format = c("csv", "xlsx"),
                                    quiet = TRUE) {
  pal::assert_pkg("xopen")
  format <- rlang::arg_match(format)
  tmp_file <- fs::file_temp(pattern = "tmp_spreadsheet",
                            ext = format)
  
  if (format == "csv") {
    
    pal::assert_pkg("readr")
    readr::write_csv(x = x,
                     file = tmp_file)
    
  } else if (format == "xlsx") {
    
    pal::assert_pkg("writexl")
    writexl::write_xlsx(x = x,
                        path = tmp_file)
  }
  
  xopen::xopen(target = tmp_file,
               quiet = quiet)
  
  invisible(x)
}

#' Deploy pkgdown site to local Git folder
#'
#' @description
#' Copies the static [pkgdown][pkgdown::pkgdown] website files to another local Git folder, then stages, commits and pushes the changes. Use
#' [pkgdown::build_site()] before running this function in order to create the website files.
#'
#' Use this function with **caution** since by default it **completely wipes the `to_path` directory**!
#' 
#' @details
#' `r pkgsnip::md_snip("rstudio_addin_hint")`
#'
#' # Setting `to_path` via \R options
#'
#' Instead of directly providing a valid `to_path` argument, you can also set `to_path = NULL` and provide
#'
#' - the desired deploy paths for each package in the \R option `yay.local_pkgdown_deploy_paths`. The value of this option must be a named character vector
#'   whereas the names correspond to the package names and the values to the filesystem paths. As an example:
#' 
#'   ```r
#'   options(yay.local_pkgdown_deploy_paths = c(some_pkg    = "/path/to/common_pkgdown_repo/some_pkg",
#'                                              another_pkg = "/path/to/common_pkgdown_repo/another_pkg",
#'                                              foo_pkg     = "/path/to/dedicated_foo_pkgdown_repo"))
#'   ```
#'
#' - a default parent path in the \R option `yay.default_local_pkgdown_deploy_parent_path` that will be used as the deployment parent directory for all packages
#'   that are not explicitly listed in `yay.local_pkgdown_deploy_paths`. For example you could set
#' 
#'   ```r
#'   options(yay.default_local_pkgdown_deploy_parent_path = "/path/to/common_pkgdown_repo")
#'   ```
#'   
#'   which would result in deploying the pkgdown website files of a hypothetical package named _bar_pkg_ to `/path/to/common_pkgdown_repo/bar_pkg`.
#'
#' A suitable place to define the above options is the [`.Rprofile`
#' file](https://support.rstudio.com/hc/en-us/articles/360047157094-Managing-R-with-Rprofile-Renviron-Rprofile-site-Renviron-site-rsession-conf-and-repos-conf)
#' in the user's home directory.
#'
#' @param pkg_path Path to the \R package of which the pkgdown website files are to be deployed.
#' @param to_path Path to the Git (sub)folder to which the pkgdown website files are to be deployed. If `NULL`, the \R options `yay.local_pkgdown_deploy_paths`
#'   and `yay.default_local_pkgdown_deploy_parent_path` will be respected. See section _Setting `to_path` via R options_ for details.
#' @param use_dev_build Whether to deploy the development build of the pkgdown website files. If `NULL`,
#'   [`development.mode`](https://pkgdown.r-lib.org/reference/build_site.html#development-mode) set in the pkgdown YAML configuration file from `pkg_path` will
#'   be respected.
#' @param clean_to_path Whether to completely wipe `to_path` before deploying the new pkgdown website files. Setting this to `TRUE` ensures there are no
#'   obsolete files left over from previous deployments.
#' @param commit_msg The Git commit message used for the deployment.
#'
#' @return A vector of paths to the deployed files/folders, invisibly.
#' @export
deploy_pkgdown_site <- function(pkg_path = ".",
                                to_path = NULL,
                                use_dev_build = NULL,
                                clean_to_path = TRUE,
                                commit_msg = paste0("auto-deploy pkgdown site for ",
                                                    desc::desc_get_field(file = pkg_path,
                                                                         key = "Package"))) {
  pal::assert_pkg("desc")
  pal::assert_pkg("gert")
  pal::assert_pkg("pkgdown")
  checkmate::assert_flag(use_dev_build,
                         null.ok = TRUE)
  checkmate::assert_flag(clean_to_path)
  
  if (!(pal::is_pkgdown_dir(pkg_path))) {
    rlang::abort(cli::format_error("No pkgdown configuration found under path: {.path {pkg_path}}"))
  }
  
  # get pkg's pkgdown config
  override <-
    use_dev_build %>%
    purrr::when(isTRUE(.) ~ list(development = list(mode = "devel")),
                isFALSE(.) ~ list(development = list(mode = "release")),
                ~ list())
  
  config <- pkgdown::as_pkgdown(pkg = pkg_path,
                                override = override)
  
  # determine `to_path` if necessary
  arg_to_path <- to_path
  to_path <- to_path %||% getOption("yay.local_pkgdown_deploy_paths")[config$package]
  to_path_parent <- getOption("yay.default_local_pkgdown_deploy_parent_path")
  to_path <- to_path %||% fs::path_join(c(to_path_parent, config$package))
  to_path_parent <- fs::path_dir(to_path)
  
  if (!checkmate::test_path_for_output(to_path,
                                       overwrite = TRUE)) {
    if (is.null(arg_to_path)) {
      if (is.null(getOption("yay.local_pkgdown_deploy_paths")[config$package])) {
        if (!is.null(getOption("yay.default_local_pkgdown_deploy_parent_path"))) {
          rlang::abort(cli::format_error(paste0("The R option {.field yay.default_local_pkgdown_deploy_parent_path} is set, but not to a valid filesystem path",
                                                " with write access. Current option value: {.path {to_path_parent}}")))
        } else {
          rlang::abort(cli::format_error(paste0("Either set {.arg to_path} directly to a valid filesystem path or provide the path in the R option {.field ",
                                                "yay.local_pkgdown_deploy_paths} as a named character vector of the form {.code c({config$package} = ",
                                                "\"/path/to/local_git_repo\")}. Another alternative is to set a default parent path in the R option {.field ",
                                                "yay.default_local_pkgdown_deploy_parent_path}. See {.code ?yay::deploy_pkgdown_site} for details.")))
        }
      } else {
        rlang::abort(cli::format_error(paste0("The R option {.field yay.local_pkgdown_deploy_paths[\"{config$package}\"]} is set, but not to a valid ",
                                              "filesystem path with write access. Current option value: {.path {to_path}}")))
      }
    } else {
      rlang::abort(cli::format_error("{.arg {to_path}} is not a valid filesystem path."))
    }
  }
  
  # create pkg website subfolder if necessary (only leaf directory will be created because of `checkmate::test_path_for_output()` above)
  if (!fs::dir_exists(to_path)) fs::dir_create(path = to_path)
  
  repo <- to_path %>% gert::git_find()
  
  # clean destination path if requested
  if (clean_to_path) {
    
    fs::dir_walk(path = to_path,
                 fun = fs::dir_delete,
                 type = "directory")
    
    fs::dir_walk(path = to_path,
                 fun = fs::file_delete,
                 all = TRUE,
                 type = "file")
    
    gert::git_status(repo = repo,
                     staged = FALSE) %>%
      dplyr::filter(status == "deleted"
                    & fs::path_has_parent(path = file,
                                          parent = fs::path_rel(path = to_path ,
                                                                start = repo))) %$%
      file %>%
      gert::git_add(repo = repo)
  }
  
  # copy files/dirs
  dirs <- fs::dir_ls(path = config$dst_path,
                     type = "directory",
                     regexp = paste0("^\\Q", fs::path(config$dst_path, config$development$destination), "\\E"),
                     all = TRUE,
                     invert = TRUE)
  
  dirs %>% purrr::walk2(.y =
                          dirs %>%
                          fs::path_rel(start = config$dst_path) %>%
                          fs::path(to_path, .),
                        .f = fs::dir_copy,
                        overwrite = TRUE)
  
  files <- fs::dir_ls(path = config$dst_path,
                      type = "file",
                      all = TRUE)
  
  files %>% purrr::walk(fs::file_copy,
                        new_path = to_path,
                        overwrite = TRUE)
  
  # commit and push files
  staged <-
    c(dirs, files) %>%
    fs::path_rel(start = config$dst_path) %>%
    fs::path(fs::path_rel(path = to_path,
                          start = repo),
             .) %>%
    gert::git_add(repo = repo)
  
  if (nrow(staged)) {
    
    gert::git_commit(message = checkmate::assert_string(commit_msg),
                     repo = repo)
    
    gert::git_push(repo = repo)
    
  } else {
    message("No files changed.")
  }
  
  invisible(fs::path_abs(path = staged$file,
                         start = repo))
}

#' Replace matched patterns in strings _verbosely_
#'
#' Applies a series of regular-expression-replacement pairs to one or more strings. All performed replacements are displayed on the console by default
#' (`verbose = TRUE`).
#'
#' This function provides a subset of [stringr::str_replace_all()]'s functionality. If you don't need the visual console output, it's recommended to directly
#' resort to the latter.
#'
#' @param pattern A named character vector with patterns as names and replacements as values (`c(pattern1 = replacement1)`). Patterns are interpreted as
#'   regular expressions as described in [stringi::stringi-search-regex()]. Replacements are interpreted as-is, except that references of the form `\1`, `\2`,
#'   etc. will be replaced with the contents of the respective matched group (created in patterns using `()`). Pattern-replacement pairs are processed in the
#'   order given, meaning that first listed pairs are applied before later listed ones.
#' @param verbose Whether to display replacements on the console.
#' @param n_context_chrs The (maximum) number of characters displayed around the actual `string` and its replacement. The number refers to a single side of
#'   `string`/replacement, so the total number of context characters is at the maximum `2 * n_context_chrs`. Only relevant if `verbose = TRUE`.
#' @inheritParams stringr::str_replace_all
#'
#' @return A character vector.
#' @family string
#' @export
#'
#' @examples
#' "Make love, not war" %>%
#'   yay::str_replace_verbose(pattern = c("love" = "hummus",
#'                                        "war" = "walls"))
#'
#' # pattern-replacement pairs are processed one-by-one, so the following gives the same result
#' "Make love, not war" %>%
#'   yay::str_replace_verbose(pattern = c("love" = "hummus",
#'                                        "hummus, not war" = "hummus, not walls"))
#'
#' # varying `n_context_chrs` affects console output summarization
#' input <- c("Tulips are not durable, ",
#'            "not scarce, ",
#'            "not programmable, ",
#'            "not fungible, ",
#'            "not verifiable, ",
#'            "not divisible, ",
#'            "and hard to transfer. ",
#'            "But tell me more about your analogy...",
#'            "",
#'            "-[Naval Ravikant](https://twitter.com/naval/status/939316447318122496)")
#'
#' pattern <- c("not" = "extremely",
#'              "hard" = "ridiculously easy",
#'              "^But.*" = "So... flower power?",
#'              "(^-).*Naval.*" = "\\1\U0001F92A")
#'
#' yay::str_replace_verbose(string = input,
#'                          pattern = pattern,
#'                          n_context_chrs = 5L) %>%
#'   pal::cat_lines()
#'
#' yay::str_replace_verbose(string = input,
#'                          pattern = pattern,
#'                          n_context_chrs = 0L) %>%
#'   pal::cat_lines()
str_replace_verbose <- function(string,
                                pattern,
                                verbose = TRUE,
                                n_context_chrs = 20L) {
  
  checkmate::assert_flag(verbose)
  checkmate::assert_character(pattern, any.missing = FALSE)
  if (!checkmate::test_named(pattern)) rlang::abort("All elements of `pattern` must be named (names are patterns, values are replacements).")
  n_context_chrs <- checkmate::assert_count(n_context_chrs, coerce = TRUE)
  
  # print replacement info for humans
  if (verbose) {
    
    pal::assert_pkg("cli")
    
    # we have to process each pattern-replacement pair one-by-one because other than `stringr::str_replace_all()`, `stringr::str_locate_all()` doesn't support
    # the pair-wise spec
    string_changed <- string
    msgs <- tibble::tibble(minus = character(),
                           plus = character(),
                           i_pattern = integer())
    
    for (i in seq_along(pattern)) {
      
      msgs <-
        str_replace_verbose_single_info(string = string_changed,
                                        pattern = pattern[i],
                                        n_context_chrs = n_context_chrs) %>%
        dplyr::mutate(i_pattern = i) %>%
        dplyr::bind_rows(msgs, .)
      
      string_changed %<>% stringr::str_replace_all(pattern = pattern[i])
    }
    
    msgs %>%
      dplyr::group_by(minus, plus) %>%
      dplyr::summarise(i_pattern = pal::safe_min(i_pattern),
                       n = dplyr::n(),
                       .groups = "drop") %>%
      # since summarizing can change row order, we need to restore the original order
      dplyr::arrange(i_pattern) %>%
      purrr::pwalk(function(minus, plus, i_pattern, n) {
        
        # using string interpolation ensures `{` and `}` are escaped, cf. ?cli::`inline-markup`
        cat(n, "\u00D7 ", minus, "\n",
            sep = "")
        cat(rep("\u00A0", times = nchar(n) + 2L), plus, "\n",
            sep = "")
      })
    
    result <- string_changed
    
  } else {
    result <- stringr::str_replace_all(string = string,
                                       pattern = pattern)
  }
  
  # return result
  result
}

# helper to generate info for single replacement 
str_replace_verbose_single_info <- function(string,
                                            pattern,
                                            n_context_chrs) {
  
  # escape newlines (in case replacement contains newlines)
  replacement <- pal::escape_lf(as.character(pattern))
  
  stringr::str_locate_all(string = string,
                          pattern = names(pattern)) %>%
    purrr::map2_dfr(.y = string,
                    .f = function(positions, string) {
                      
                      positions %<>% dplyr::as_tibble() %>% dplyr::filter(start <= end)
                      
                      purrr::map2_dfr(.x = positions$start,
                                      .y = positions$end,
                                      .f = function(start, end) {
                                        
                                        # reduce to `string` excerpt of +/- `n_context_chrs`
                                        ## determine if we prune
                                        prune_start <- (start - n_context_chrs) > 1L 
                                        prune_end <- (end + n_context_chrs) < nchar(string)
                                        
                                        ## extract excerpt
                                        ### begin (part before `pattern`)
                                        excerpt_begin <- string %>% stringr::str_sub(start = dplyr::if_else(prune_start,
                                                                                                            start - n_context_chrs,
                                                                                                            1L),
                                                                                     end = start - 1L)
                                        ### the `pattern` as-is, i.e. without regex syntax
                                        pattern_asis <- string %>% stringr::str_sub(start = start,
                                                                                    end = end)
                                        
                                        ### end (part after `pattern`)
                                        excerpt_end <- string %>% stringr::str_sub(start = end + 1L,
                                                                                   end = dplyr::if_else(prune_end,
                                                                                                        end + n_context_chrs,
                                                                                                        -1L))
                                        
                                        # replace excerpt start/end with ellipsis dots (pruned to whole words if appropriate)
                                        if (prune_start) excerpt_begin %<>% paste0(unicode_ellipsis, .)
                                        
                                        if (prune_end) excerpt_end %<>% paste0(unicode_ellipsis)
                                        
                                        # escape newlines (in case pattern contains newlines)
                                        excerpt_begin %<>% pal::escape_lf()
                                        pattern_asis %<>% pal::escape_lf()
                                        excerpt_end %<>% pal::escape_lf()
                                        
                                        # assemble info msgs
                                        tibble::tibble(minus = pal::as_string(cli::col_red("-"), " ", cli::bg_black(excerpt_begin),
                                                                              cli::style_strikethrough(bg_red_dark(pattern_asis)), cli::bg_black(excerpt_end)),
                                                       plus = pal::as_string(cli::col_green("+"), " ", cli::bg_black(excerpt_begin), bg_green_dark(replacement),
                                                                             cli::bg_black(excerpt_end)))
                                      })
                    })
}

#' Replace matched patterns in text files
#'
#' Applies pattern-based string replacements to one or more files. Expects a series of regular-expression-replacement pairs that are applied one-by-one in the
#' given order. All performed replacements are displayed on the console by default (`verbose = TRUE`), optionally without actually changing any file content
#' (`run_dry = TRUE`).
#'
#' Note that `process_line_by_line` requires the [line ending standard (EOL)](https://en.wikipedia.org/wiki/Newline) of the input files to be correctly set in
#' `eol`. It _always_ defaults to `"LF"` (Unix standard) since this is something which cannot be reliably detected without complex heuristics (and even then
#' not unambiguously in all edge cases). Simply deriving a default depending on the host OS (i.a. `"LF"` on Unix systems like Linux and macOS and `"CRLF"` on
#' Windows) seems like a really bad idea with regard to cross-system collaboration (files shared via Git etc.), thus it was refrained from.
#'
#' The text files are assumed to be in [UTF-8 character encoding](https://en.wikipedia.org/wiki/UTF-8), other encodings are not supported.
#'
#' @param path Paths to the text files. A character vector.
#' @param process_line_by_line Whether each line in a file should be treated as a separate string or the whole file as one single string. While the latter is 
#'   more performant, you probably want the former if you're using `"^"` or `"$"` in your `pattern`s.
#' @param eol End of line (EOL) control character sequence. Only relevant if `process_line_by_line = TRUE`. One of
#'   - `"LF"` for the line feed (LF) character (`"\n"`). The standard on Unix and Unix-like systems (Linux, macOS, *BSD, etc.) and the **default**.
#'   - `"CRLF"` for the carriage return + line feed (CR+LF) character sequence (`"\r\n"`). The standard on Microsoft Windows, DOS and some other systems.
#'   - `"CR"` for the carriage return (CR) character (`"\r"`). The standard on classic Mac OS and some other antiquated systems.
#'   - `"LFCR"` for the line feed + carriage return (LF+CR) character sequence (`"\n\r"`). The standard on RISC OS and some other exotic systems.
#' @param show_rel_path Whether to display file `path`s as relative from the current working directory. If `FALSE`, absolute paths are displayed. Only relevant
#'   if `verbose = TRUE`.
#' @param run_dry Whether to show replacements on the console only, without actually modifying any files. Implies `verbose = TRUE`.
#' @inheritParams str_replace_verbose
#'
#' @return `path` invisibly.
#' @family string
#' @export
str_replace_file <- function(path,
                             pattern,
                             process_line_by_line = FALSE,
                             eol = c("LF", "CRLF", "CR", "LFCR"),
                             verbose = TRUE,
                             n_context_chrs = 20L,
                             show_rel_path = TRUE,
                             run_dry = TRUE) {
  
  pal::assert_pkg("brio")
  checkmate::assert_file(path,
                         access = "r")
  checkmate::assert_flag(process_line_by_line)
  eol %<>% as_line_feed_chr()
  checkmate::assert_flag(verbose)
  checkmate::assert_flag(show_rel_path)
  checkmate::assert_flag(run_dry)
  
  if (run_dry && !verbose) {
    rlang::abort("Setting `run_dry = TRUE` and `verbose = FALSE` at the same time is pointless.")
    
  } else if (run_dry) {
    cli::cli_alert_info("Running in dry mode. Set {.code run_dry = FALSE} to actually modify any files.")
  }
  
  purrr::walk(.x = path,
              .f = function(path) {
                
                # print file progress info
                if (verbose) {
                  
                  pal::assert_pkg("cli")
                  
                  path_show <- dplyr::if_else(show_rel_path,
                                              fs::path_rel(path),
                                              fs::path_abs(path))
                  
                  cli::cli_alert_info(text = "Processing file {.file {path_show}}{unicode_ellipsis}")
                }
                
                # perform replacement
                input <- brio::read_file(path = path)
                
                if (process_line_by_line) {
                  input %<>% stringr::str_split(pattern = eol) %>% dplyr::first()
                }
                
                output <- str_replace_verbose(string = input,
                                              pattern = pattern,
                                              verbose = verbose,
                                              n_context_chrs = n_context_chrs)
                
                if (!run_dry && !identical(input, output)) {
                  
                  brio::write_file(text = paste0(output,
                                                 collapse = eol),
                                   path = path)
                }
              })
  
  invisible(path)
}

#' Apply regular-expression-based text normalization to strings
#'
#' Applies a set of regular-expression-based text normalization rules to one or more strings. All performed replacements are displayed on the console by default
#' (`verbose = TRUE`).
#'
#' @param rules A [tibble][tibble::tibble()] of regular expression patterns and replacements. It must have the columns `pattern` and `replacement`. `pattern`
#'   can optionally be a list column condensing multiple patterns to the same replacement rule. Patterns are interpreted as regular expressions as described
#'   in [stringi::stringi-search-regex()]. Replacements are interpreted as-is, except that references of the form `\1`, `\2`, etc. will be replaced with the
#'   contents of the respective matched group (created in patterns using `()`). Pattern-replacement pairs are processed in the order given, meaning that first
#'   listed pairs are applied before later listed ones.
#' @inheritParams str_replace_verbose
#'
#' @inherit str_replace_file return
#' @family string
#' @seealso [`regex_text_normalization`] [`regex_file_normalization`]
#' @export
#'
#' @examples
#' "This kind of ‚Äútext normalization‚Äù is e.g. useful to apply before feeding stuff to ‚ÄòPandoc‚Äô" %>%
#'   yay::str_normalize()
str_normalize <- function(string,
                          rules = yay::regex_text_normalization,
                          n_context_chrs = 20L,
                          verbose = TRUE) {
  rules %>%
    tidyr::unnest_longer(col = pattern) %$%
    magrittr::set_names(x = replacement,
                        value = pattern) %>%
    str_replace_verbose(string = string,
                        n_context_chrs = n_context_chrs,
                        verbose = verbose)
}

#' Apply regular-expression-based text normalization to files
#'
#' Applies a set of regular-expression-based text normalization rules to one or more files. By default, changes are shown on the console only, without actually
#' modifying any files. Set `run_dry = FALSE` to apply the changes.
#'
#' @inheritParams str_normalize
#' @inheritParams str_replace_file
#'
#' @inherit str_replace_file return
#' @family string
#' @seealso [`regex_text_normalization`] [`regex_file_normalization`]
#' @export
#'
#' @examples
#' # Use POSIX-related file normalization rule(s) included in this package
#' temp_file <- tempfile()
#' download.file(url = paste0("https://raw.githubusercontent.com/RcppCore/Rcpp/72f0652b93f196d",
#'                            "64faab6b108cd02a197510a7b/inst/include/Rcpp/utils/tinyformat.h"),
#'               destfile = temp_file)
#'
#' yay::regex_file_normalization %>%
#'   dplyr::filter(category == "posix") %>%
#'   yay::str_normalize_file(path = temp_file)
str_normalize_file <- function(path,
                               rules = yay::regex_text_normalization,
                               run_dry = TRUE,
                               process_line_by_line = FALSE,
                               n_context_chrs = 20L,
                               verbose = TRUE) {
  rules %>%
    tidyr::unnest_longer(col = pattern) %$%
    magrittr::set_names(x = replacement,
                        value = pattern) %>%
    str_replace_file(path = path,
                     n_context_chrs = n_context_chrs,
                     process_line_by_line = process_line_by_line,
                     verbose = verbose,
                     run_dry = run_dry)
}
